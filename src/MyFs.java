import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.PosixFilePermission;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class MyFs {
    public static void listDirectory(String path) { // ls <path>
        try {
            List<String> files = new ArrayList<>();
            File[] fileList = new File(path).listFiles();
            if (fileList != null) {
                for (File file : fileList) {
                    files.add(file.getName());
                }
                if (files.size() != 0) {
                    for (String fileName : files) {
                        System.out.print(fileName + "  ");
                        if (files.indexOf(fileName) == files.size() - 1) {
                            System.out.println(); // переводим каретку на следующую строку
                        }
                    }
                } else {
                    System.out.println("Директория пуста");
                }
            }
        } catch (Exception e) {
            handleException(e);
        }
    }

    public static void listPythonFiles(String path) { //ls_py <path>
        try {
            List<String> files = new ArrayList<>();
            File[] fileList = new File(path).listFiles();
            if (fileList != null) {
                for (File file : fileList) {
                    String fileName = file.getName();
                    if (fileName.substring(fileName.length() - 3).equals(".py")) {
                        files.add(fileName);
                    }
                }
                if (files.size() != 0) {
                    for (String fileName : files) {
                        System.out.print(fileName + "  ");
                        if (files.indexOf(fileName) == files.size() - 1) {
                            System.out.println(); // переводим каретку на следующую строку
                        }
                    }
                } else {
                    System.out.println("Файлов с расширением .py нет");
                }
            }
        } catch (Exception e) {
            handleException(e);
        }
    }

    public static boolean isDirectory(String path) {
        try {
            File checkDirectory = new File(path);
            if (checkDirectory.isDirectory()) {
                return true;
            }
        } catch (Exception e) {
            handleException(e);
        }
        return false;
    }

    public static void defineDirOrFile(String path) {
        try {
            File check = new File(path);
            if (check.isDirectory()) {
                System.out.println("директория");
            } else if (check.isFile()) {
                System.out.println("файл");
            } else {
                System.out.println("Дириктория или файл не существуют");
            }
        } catch (Exception e) {
            handleException(e);
        }
    }

    public static void printContent(String path) {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            handleException(e);
        }
    }

    public static void appendFooter(String path) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(path, true))) {
            writer.newLine();
            writer.write("# Autogenerated line");
            System.out.println("Строка успешно добавлена.");
        } catch (IOException e) {
            handleException(e);
        }
    }

    public static void createBackup(String path) {
        try {
            String date = new SimpleDateFormat("dd-MM-yyyy").format(new Date());
            Path destinationPath = Paths.get("/tmp/" + date + ".backup");
            Files.createDirectories(destinationPath);

            if (Files.isDirectory(destinationPath)) {
                if (Files.isDirectory(Paths.get(path))) {
                    copyDirectory(Paths.get(path), destinationPath.resolve(Paths.get(new File(path).getName())));
                } else {
                    File destFile = destinationPath.resolve(Paths.get(new File(path).getName())).toFile();
                    copyFile(new File(path), destFile);
                }
                System.out.println("Резервная копия успешно создана.");
            }
        } catch (IOException e) {
            handleException(e);
        }
    }

    private static void copyDirectory(Path source, Path destination) throws IOException {
        Files.walkFileTree(source, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                Path targetDir = destination.resolve(source.relativize(dir));
                Files.createDirectories(targetDir);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Path targetFile = destination.resolve(source.relativize(file));
                Files.copy(file, targetFile, StandardCopyOption.REPLACE_EXISTING);
                return FileVisitResult.CONTINUE;
            }
        });
    }

    private static void copyFile(File source, File destination) throws IOException {
        try (FileInputStream in = new FileInputStream(source);
             FileOutputStream out = new FileOutputStream(destination)) {
            byte[] buffer = new byte[1024];
            int length;
            while ((length = in.read(buffer)) > 0) {
                out.write(buffer, 0, length);
            }
        }
    }

    public static void printLongestWord(String path) {
        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
            String longestWord = "";
            String line;
            while ((line = reader.readLine()) != null) {
                String[] words = line.split("\\s+");
                for (String word : words) {
                    if (word.length() > longestWord.length()) {
                        longestWord = word;
                    }
                }
            }
            System.out.println("Самое длинное слово: " + longestWord);
        } catch (IOException e) {
            handleException(e);
        }
    }

    public static void printPermissions(String path) {
        File file = new File(path);
        try {
            if (file.exists()) {
                System.out.print(file.canRead() ? "r" : "-");
                System.out.print(file.canWrite() ? "w" : "-");
                System.out.println(file.canExecute() ? "x" : "-");
            } else {
                System.out.println("File does not exist: " + file.getAbsolutePath());
            }
        } catch (Exception e) {
            handleException(e);
        }
    }

    public static void setPermissions(String path, String permissions) {
        String regex = "^[r-][w-][x-][r-][w-][x-][r-][w-][x-]$";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(permissions);

        if(permissions.length() != 9) {
            System.out.println("Неверное количсетво аргументов в <perm>. Количество аргументов должнобыть равным 9.");
        } else if (!matcher.matches()) {
            System.out.println("Указан неверный символ права в <perm>. Формат \"rwxrwxrwx\" или '-' - для снятия прав");
        } else {
            try {
                // Путь к файлу, для которого устанавливаются права доступа
                Path filePath = FileSystems.getDefault().getPath(path);


                // Устанавливаемые права доступа
                Set<PosixFilePermission> permissionSet = new HashSet<>();

                // Устанавливаем права для владельца, группы и остальных
                addPermissions(permissionSet, PosixFilePermission.OWNER_READ, 'r', permissions, 0);
                addPermissions(permissionSet, PosixFilePermission.OWNER_WRITE, 'w', permissions, 1);
                addPermissions(permissionSet, PosixFilePermission.OWNER_EXECUTE, 'x', permissions, 2);

                addPermissions(permissionSet, PosixFilePermission.GROUP_READ, 'r', permissions, 3);
                addPermissions(permissionSet, PosixFilePermission.GROUP_WRITE, 'w', permissions, 4);
                addPermissions(permissionSet, PosixFilePermission.GROUP_EXECUTE, 'x', permissions, 5);

                addPermissions(permissionSet, PosixFilePermission.OTHERS_READ, 'r', permissions, 6);
                addPermissions(permissionSet, PosixFilePermission.OTHERS_WRITE, 'w', permissions, 7);
                addPermissions(permissionSet, PosixFilePermission.OTHERS_EXECUTE, 'x', permissions, 8);

                // Устанавливаем права доступа к файлу
                Files.setPosixFilePermissions(filePath, permissionSet);

                System.out.println("Права доступа успешно установлены.");
            } catch(Exception e){
                handleException(e);
            }
        }
    }

    private static void addPermissions(Set<PosixFilePermission> permissionSet, PosixFilePermission permission, char symbol, String permissions, int index) {
        if (permissions.charAt(index) == symbol) {
            permissionSet.add(permission);
        }
    }


    public static void help() {
        System.out.println("MyFS 1.0 команды:");
        System.out.println("ls <path>               выводит список всех файлов и директорий для `path`");
        System.out.println("ls_py <path>            выводит список файлов с расширением `.py` в `path`");
        System.out.println("is_dir <path>           выводит `true`, если `path` это директория, в других случаях `false`");
        System.out.println("define <path>           выводит `директория` или `файл` в зависимости от типа `path`");
        System.out.println("readmod <path>          выводит права для файла в формате `rwx` для текущего пользователя");
        System.out.println("setmod <path> <perm>    устанавливает права для файла `path`");
        System.out.println("cat <path>              выводит контент файла");
        System.out.println("append <path>           добавляет строку `# Autogenerated line` в конец `path`");
        System.out.println("bc <path>               создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`");
        System.out.println("greplong <path>         выводит самое длинное слово в файле");
        System.out.println("help                    выводит список команд и их описание");
        System.out.println("exit                    завершает работу программы");
    }

    public static void exit() {
        System.out.println("Goodbye");
        System.exit(0);
    }

    private static void handleException(Exception e) {
        System.out.println("Произошла неизвестная ошибка: " + e.getMessage());
        e.printStackTrace();
    }

    private static void handleException(IOException e) {
        System.out.println("Произошла ошибка ввода-вывода: " + e.getMessage());
        e.printStackTrace();
    }
}
